<div class="story">
  <h1>NodeJs</h1>

  <h2>Concurrency Model and Event Loop</h2>
  <h3>What is I/O Anyway</h3>
  <p>
    Okay, so we know that I/O is short for input/output, but what exactly does that mean? I/O is used to label a communication
    between a process in a computer CPU and anything external to that CPU, including memory, disk, network, and even another process.
    The process communicates with these external things with signals or messages. Those signals are input when they are received by the
    process, and output when they are sent out by the process. The term I/O is really overused, because naturally, almost every operation
    that happens inside and outside computer is an I/O operation, but when talking about Node's architechture, the term I/O is usually used
    to reference accessing disk and network resources, which is the most time-expensive part of all operations. Node's event loop is designed
    around the major fact that the largest waste in computer programming comes from waiting in such I/O operations to complete. We can
    handle requests for these slow operations in one of many ways. We can just execute things synchronously. This is the easiest way to
    go about it, but it's horrible because one request is going to hold up other requests. We can fork a new process from the OS to handle
    each request, but that's probably won't scale very well with a lot of requests. The most popular method for handling these requests is threads.
    We can start a new thread to handle each request. BBut threaded programming can get very complicated when threads start accessing shared resources.
    A lot of popular libraries and frameworks use threads. For example, Apache is multithreaded and it usually creates a thread per request.
    On the other hand, its major alternative, Nginx is single threaded, just like Node, which eliminates the overhead created by these multiple threads
    and simplify coding for sharde resources. Single threaded frameworks like Node use an event loop to handle requests for slow I/O opeartions
    without blocking the main execution runtime. This is the most important concept to understand about Node, so how exactly does this event loop work?
  </p>

  <h3>The Event Loop</h3>
  <p>
    The simplest one-line definition of the event loop is this - it's the entity that handles external events and converts them into
    callback invocations. Helpful? Maybe not. Let's try another definition: It's the loop that picks events from the event queue and pushes
    their callbacks to the call stack. This definition is probably worse than the first one. Truth is, it's not easy to understand the event loop
    without first understanding the data structures it has to deal with. It's also a lot easier to understand the event loop with
    visuals rather than text, so the next few clips will explain the various things around the event loop with visuals. What I want you to
    understand first is that there is this thing called the event loop that Node automatically starts when it executes a script, so
    there is no need for us to manually start it. This event loop is what makes the asynchronous callback programming style possible. Node will
    exit the event loop when there are no more callbacks to perform. The event loop is also present in browsers and it's very similar to the one
    that fires in Node. To understand event loop, wee need to understand all the players in this diagram and we need to understand how they interact.
    So V8 has this thing called stack, which we're going to cover in details in the next section. It also has a heap. The heap is simple, it is
    where objects are stored in memory. It's basically the memory that gets allocated by the VM for various tasks. For example, when we invoke a function,
    an area in this heap is allocated to act as the local scope of that function. Both the Stack and the Heap are part of the run-time engine, not
    Node itself. Node adds APIs like timers, emitters, and wrappers around OS operations. It also provides the event Queue and the event loop using the
    libuv library. The event loop,  as the name cleary describes, is a simple loop that works between the event queue and the call stack.
    But again, we can't understand it without first understanding those other entities.
  </p>
  
  <h2>Node for Networing</h2>
  <h3>TCP Networking with the Net Module</h3>
  <p>
    Let's create a basic network server. We use the net's module, create server method.
    We then need to register a connection handler that fires every time ad client connects
    to this server. When that happens, let's log to the console and see if the client is connected.
    The handler also gives us access to a connected socket itself. This socket object implements
    a duplex stream interface, which means that we can read and write to it. Let's write "Welcome
    new Client". To run the server we need to listen to a port, and the callback here is just to
    confirm it. Let's test. Testing this is simple, we can use either telnet or netcat.
    For example, nc localhost 8000, we get the client is connected message in the server console, and
    the welcome message is sent to the client, and then node keeps running, because we did not terminate
    that connection. Now the client can write to that socket, but we have not registered a handler to read
    from the socket. The socket being a duplex stream means that it's also an EventEmitter. So we can listen
    to data event on the socket. The handler for this event gives us access to a buffer object. Let's console
    log it. Now when the client types something, we get it as a buffer. This is great, because Node does not
    assume anything about encoding. The user can be typing here in any language. Let's now echo this data
    object back to the user using socket.write. When we do so, you'll notice that the data we are writing back
    is actually a string. This is because the write method on the socket assumes a utf8 encoding here.
    This second argument can be used to control the encoding and the default is utf8. We can also globally
    set the encoding if we need to, so the global encoding is now utf8 and the data argument here becomes
    a string instead of a buffer, because we now told Node to assume a utf8 encoding for anything received
    from this socket. Both the console log line and the echoed data are assumed to be utf8. I'm gonna keep
    an example without global encoding, just in case we need access to the buffer object. What happens
    when the client disconnects? The socket emitter has an on 'end' event that gets triggered when the
    client disconnects? The socket emitter has an on 'end' event that gets triggered when the client disconnects.
    At that point, we can't write to the socket any more. Let's console log that client is disconnected.
    Let's test that now. Connect, and we can disconnect a netcat session with Cmd+D. The server logs the line.
  </p>

  <h3>Working with Multiple Sockets</h3>


  <h2>Node for Web</h2>
  <h3>The Basic Streaming HTTP Server</h3>
  <p>
    HTTP is a first class citizen in Node. In fact, node started as web server and evolved into
    much more generalized framework it is today. Node's HTTP module designed with streaming and low latency
    in mind. Node is today a very popular tool to create and run web servers. Let's look at the typical hello-world
    example for Node's http module. We create a server using the HTTP module create server method, which gives
    us, no surprise there, an event emitter object. That event emitter has many events, one of which is the request
    event, and this even happens every time a client connects to this http server. It exposes a request object and a
    response object. We can use the response object to modify the response Node will be using for that request.
    In here, we respond with 200 ok, content-type text, and the text 'hello world'. The server runs on port 8000.
    When we run this script, node will not exit, because it has a listener handler and it will respond to any
    http request on port 8000. If we inspect the headers this simple http server is sending, we'll see http 1.1,
    this is the current most recent version of http that's supported in browsers. Response code is 200 ok, and the content-type
    is what we set it to, and we have a connection keep-alive and transfer-encoding is chunked. Keep-alive means
    that the connection to the web server will be persisted. The tcp connection will not be killed after a request
    receives a response, so that they can send multiple requests on the same connection. Transfer-encoding chunked is used
    to send a variable length response text. It basically means that the response is being streamd! Node is ok with us
    sending partial chunked reponses, because the response object is a writable stream. There is no response length value
    being sent. After Node sends the 200 ok here, it can do many other things before terminating the response, and instead
    of inefficiently buffering everything it wants to write in memory and then write it at once, it can just stream
    parts of the response as they're ready. So this very simple http server can be used, for example, to stream video files
    out of the box. But remember that the connection is not terminated here, so the browser knows that the content
    is done through the http protocol. Http 1.1 has a way of terminating a message, and it's what happens when we use the
    response .end function. Si if we don't actually use the end method, if we use the write method instead, in this case,
    when a client connects, they get the 'hello world', but the response is not terminated, because basically Node is still streaming.
    In fact, in here, we can define a timer function. Let's make that fire after on second. And inside this function,
    we'll go  ahead and write another message. And how about we write yet another message after two seconds? Let's try it.
    Run the server. Connect. And you'll see 'hello world'. After one second you'll see another message, and after two seconds
    you'll see the third message. And the server is still streaming. We have not instructed http to terminate the response object.
    Let's make the timeout periods here a little bit longer. Lets do 10 seconds and 20 seconds and test that. Initiate an http request.
    I see the 'hello worl'. Node is not really sleeping, it's just idling, and it can actually handle other client
    requests during this idling phase, thatnks to the event loop. Both of these requests are being handled concurrently with the
    same node process. Please note, however, that terminating the response object with a call to the end method is not optional, you have to do it for
    every request. If you don't, the request will timeout after the default timeout period, which is set to two minutes.
    As you can see, this right line did not happen, beause it's delayed till after the default server timeout.
    We can actually control the server timeout using the timeout property, so this line will make the timeout one second,
    and you'll see now how the server is going to timeout right away.
  </p>

  <h3>Working with HTTPS</h3>
  <p>
    HTTPS is the HTTP protocol over TLS/SSL. Node has a separate module to work with HTTPS, but it's very similar to the
    HTTP module. To convert the basic HTTP server example to work with HTTPS, all we need to do is require https instead
    and provide the createServer method with an options object. This object can be used to configure multiple things. Usually
    we can pass key and certificate. Those can be buffers or strings to represent a private key and the certificate. We can also pass
    a pfx option to combine them if you want. I'll just use key insert and let's walk through a complete example. We first need to generate
    a certificate. We can use the openssl toolkit for that, which will allow us to first generate a certificate. We can have it
    encrypted or not encrypted. And it will allow us to generate a certificate signing request (CSR), and then self-sign this certificate to test it.
    Of course, the browsers will not trust our self-signed certificate, but it's good for testing purposes. We can actually combine all these
    steps wit one command that will output a private key and a certificate file for us. It will ask for some information, but since
    it's all just a test, you can use the default answers here. When this command is done, you should see a key,pem file, and a cert.pem file in the
    working directory. Now that we have these files, we just need to pass them here to the create server method. We can use the fs module to do that.
    We'll do readFileSync. Since these files are to be read once, and used for creating a server, this is okay here. We'll do ./, the key.pem file, and same
    thing for the cert. So it's cert.pem and of course we need to require the fs module, and the last thing we need to do is to change this port
    to 443, which is the defaultport for https communication. To test all that, we need to execute the script. In my environment I need to sudo this command
    to get access to the 443 port. So sudo node https.js an we have an https server. So we can go to https locaholst and the browser is going to warn us
    about the self-signed certificate. It simply means that hte bworser does not recognize this certificate, but we can trust it manually.
    And there you go, very simple.
  </p>

  <h3>Requesting HTTP/HTTPS Data</h3>
  <p>
    Node can also be used as a client for requesting http and https data. There are five major classes of objects in Node's HTTP module. The Server class
    is what we use to create the basic server, it inherits from net.Server, so it's an EventEmitter. A ServerResponse object gets created internally by an
    HTTP server. The http.Agent class is used to manage pooling sockets used in HTTP client requests. Node uses a global agent by default, but we can
    create a different agent with different options when we need to. When we initiate an HTTP request, we will be working with a ClientRequest object. This is
    different from the request object we've seen in the server example. That request object is actually an IncomingMessage object, which we're gonna see in a little bit.
    Both clientRequest and serverResponse implement the writable stream interface. IncomingMesssage objects implement the readable stream interface, and all
    three objects are event emitters. We've seen the basic server example. Let's see a basic requesst example. Let's request the HTML page at google.com with Node.
    We can use the http.request method. This method takes an option argument and it gives us access to a callback with a response for the host that we're gonna request.
    We can specify many options here. To request google.com, we need hostname is google.com, and we can use multiple other options here. For example, the default
    method is GET, but we can use a method like POST if we need to post information to a hostname. I'll leave it default, and in here we can console log the response,
    which is going to be the html at google.com. You'll notice one thing about the handler that we define in the second argument here, it doesn't have an error
    argument. It's simply because that this handler gets registered as an event listener and we also handle the error with an event listener here. So this http
    request method returns an object, and that object is an event emitter. So we can register a handler for the error event. And we can do something like
    request.on error, and handle the error in that case. Since this request object is a writable stream, we can do things like write, for example, if we're
    writing with a post method. But for get requests, we don't need that. We just need to terminate the stream ,so we do .end here and that should do it. Let's test.
    So node request and I'll pipe it on less and you'll see the response object here is an incoming message. So we can read information on this response object like status
    code.We can also read response.headers, for example, and this response object is an event emitter. It emits a data event when it receives data from the hostname. This
    data event gives us callback, and that callback's argument is a buffer. So if we want to see the actual HTML, we do toString on it, so let's actually take a look at that.
    You'll see the status code 200, the headers object, and you'll see the actual html for google.com. If we're not writing any information to the headers
    request or if we're not posting or putting or deleting data, we could actually just use the get method here. This get method is simpler. Its first argument is
    just a string with the URL that we want to read, so we need to add the http protocol in here, and we don't need to do a request.end on this. That will be done for us. So this should
    be equivalent, and this request is done using the global http agent. So the http module has a globalAgent, which node uses to manage the sockets here.
    It has some pre-configured options. We can see that agent information here if we do a request.agent. So in here you'll first see the agent information and
    then you'll see the printed information from the response. And all this interface is exactly the same if we want to work with https instead of http.
    So if we want to fetch https google.com, all we need to is replace http with https, and things will work exactly the same, but it's now
    communicating the request over https. So let me now show you where to identify these objects in the examples we.ve seen so far. In this example, the request object
    here is from the class clientRequest. This response object is of type incomingMessage. And the agent that was used for the request is of type http Agent.
    In the server example, the server object is from the http server class, the request object inside the request listener is from the incomingMessage class,
    and the response object is from the server response class.
  </p>

  <h3>Working with Routes</h3>
  <p>
    Let's see how we can work with routes using Node's http module. We have a basic server here, and what I want to do I want to support some routes. Let's try
    to support a home route, an api route, and see how we can respons to different things in there. So, to support that, we need to first read the URL
    information, and this is easy. We can use req.url to do so. So now, when I request localhost, the req/url is slash, and anything I put here I will be able to read it.
    So, to handle routes, all we need to do is we need a switch statement for this req.url. So what should we do when it's slash? Ir, what should we do when it's
    home, and so on? Let's assume that we have a /home.html file, very basic template HTML, and we want to display this file when we go to slash home. All we need to do is
    write the header, which in this case is text HTML, and then in here we want to read home that HTML and write it to the response. So we can use fs.readfileSync ./home.html.
    And of course, we need fs module and let's try it. Excellent. What if we have an about.html and now we also want to support /about.
    It's exact same code as this portion. So we can actually make it dynamic. Let's make it support both home and about, and let's make it support dynamic,
    because this is the exact req.url part. So first convert this into a template string and then this part becomes variable req.url, just like that. Let's test.
    We can now see the about page and the home page. So what should we do on the root route? How about we redirect the uer to /home? With Node, we just write a header for that.
    So it's writeHead, and we'll just use 301 here to indicate a permanent move, and the ehader that we want to write here is the location header.
    So, this is permanently moved to /home. And we still need to end the response, so now when we request the slash route, it will tell us that it was moved
    permanently to slash home. By the way, this first number here is the http status code. We can actually take a look at all the status codes using http.status_codes.
    You'll see all of them here. 301 is movde permanently. If you need to work with json data, say that we have a route there. We'll make it /api, so this route
    is going to respond with some data. Let's assume that we have the data here is a constant. This data is some kind of object and we want to respond with this data json,
    o we need to do two things. First, the content type in this case is application/json. And the information that we want to write here is a stringified version
    of the JSON object. So it's json.stringify the data variable. And we can test that. So in here if we go to /api, we'll get back a json response.
    Now what happens if we request something that does not exist? Rigth now, the server does not respons with anything adnd it will eventually timeout. So this would be this
    default case here, so we should probably respond with 404, in this case. So 404 means not found. We should still end the response here, so let's try it now.
    It will give me a 404 not found.
  </p>

  <h3>
    Parsing URLs and Query Strings</h3>
  <p>
    If you need to work with URLs, especially if you need to parse URL, Node has this URL module that you can use. It has many methods, but the most
    important is parse. The format method is also useful. So let me show you how to work with that. Before we do, let's take a look at the url api
    documentation from the nodeJS.org website. This diagram here has details on all the elements of a URL. This example is manually parsing this URL in here.
    So you can see we have the protocol, which is HTTP. There is the authentication part, which is username and password in case we have those, and then
    there is hostname and port, and both of them together is a host. And there's the path name, which is what comes after the host and before the query string.
    And then with a query string, the question mark including the query itself we call it search, but without the question mark we call it query. And pathname + search
    is called path. And if we have a hash location here it will be called hash. These are all the elements in any URL object. So if we have the URL as a
    string and we need to parse it into those elements, we can use the URL parse method. For example, I can use the url.parse method to parse this URL that I just
    grabbed from Pluralsight search, and this call is going to give me all the elements that I have in that URL. We have an HTTPS protocol. We don't have any
    authentication data. The host is pluralsight.com, and since the port is null the host and hostname is the same, there's no hash, there's a search part query part hash
    name path and the of itself, which is the full URL. We can actually also specify a second argument here true to parse the query string itself, so if we do that
    the query string will be parsed ,and reading information from the query string is as easy as doing .query.queue, for example. This will give me exactly the search
    query for that URL. If, on the other hand, you have the inverse situation, if you have an object with all these elements detailed and you want to format this
    object into a URL, you can use the url.format method. And this will give you back a string with all these URL object properties concatenated in the right way.
    If you only care about the query string, the you can use the query string module, which has many methods, as you see, but the most importantones are the parse
    method and this stringify method. So if we have an object like this one and we want to convert this object into a query string portion, all we need to do is call
    queryString.stringy on that object, and it will give me an actual string I can use in any url query. And you can see how this stringify method escaped some special
    characters by default, which is great. If you have the inverse situation, if you have a query string and you want to parse it into an object, what you need here is queryString.parse,
    and you give the string that you want to parse, and this will give you back an object parsed from that query string.
  </p>
</div>