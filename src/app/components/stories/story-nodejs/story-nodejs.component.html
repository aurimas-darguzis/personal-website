<div class="story">
  <header>
    <div class="header-title">NodeJs</div>
    <div class="meta-data">
      <span class="date-stamp">Jan 10, 2017</span>
      <span class="min-read">3 min read</span>
    </div>
  </header>

  <h1>NodeJs Concepts</h1>
  <h2>How require() Works</h2>
  <p>
    Modularity is a first class concept in Node. There are two core modules involved:
    the require function, which is available on the global object but each module gets own
    require function, and the Module module, also available on the global object, and is used
    to manage all the modules we require with the require function.
  </p>

  <p>
    Requiring a module in node is a very simple concept, to execute a require call, Node goes
    through the following sequence of steps.
  </p>
  <ul>
    <li>Resolving - to find the absolute path of a module.</li>
    <li>Loading - determined by the content of the file at the resolved path.</li>
    <li>Wrapping - what gives every module it's private scope, and what makes require local to every module.</li>
    <li>Evaluating - what the VM eventually does with the code.</li>
    <li>Caching - when we require this module again, we don't go over all the steps again.</li>
  </ul>

  <p>
    Let's see how the module looks like.
  </p>
  <div>
      <div class="code-editor">
        <div class="code-title">index.js</div>
        <div class="code">
          <pre>
console.log(module)
          </pre>
        </div>
      </div>
      <div class="node-editor">
        <div class="node-code">$ node index.js</div>
        <div class="node-output">
          <pre class="language-javascript">
<code>
Module {{'{'}}
  id: '.', <span class="comment">// object id to identify it</span>
  exports: {{'{'}}{{'}'}},
  parent: null,
  filename: '/Users/aurimasdarguzis/index.js', <span class="comment">// path to the filename can be accessed with this property</span>
  loaded: false,
  children: [],
  paths:
  [ '/Users/aurimasdarguzis/node_modules',
  '/Users/node_modules',
  '/node_modules' ]
{{ '}'}}
</code>
            </pre>
        </div>
      </div>

      <p>
        Node Modules have a one-to-one relation with files on the file-system. We require a module by loading the content of
        a file into memory. However, before we can load the content of a file into the memory, we need to find the location
        of a file.
      </p>

      <div class="example">
        For example, if we require a 'find-me' module from the index module, Node will look for find-me.js in 'path' property
        of Module object, which start looking from the current directory and go up all the way to the root directory. If it
        can't find find-me.js in any of these paths, it will throw a cannot find module error.
        <div class="code-editor">
            <div class="code-title">index.js</div>
            <div class="code">
              <pre>
require('find-me');

// $HOME/.node_modules
// $HOME/.node_libraries
// $PREFIX/lib/node

// const fs = require('fs');
              </pre>
            </div>
          </div>
        <div class="node-editor">
          <div class="node-code">
            <pre>
$ node index.js
            </pre>
          </div>
          <div class="node-output">
            
            <pre>
  module.js:472
  throw err;
  ^

Error: Cannot find module 'find-me'
at Function.Module._resolveFilename (module.js:470:15)
at Function.Module._load (module.js:418:25)
at Module.require (module.js:498:17)
at require (internal/module.js:20:19)
at Object.<span><</span>anonymous> (/Users/aurimasdarguzis/index.js:1:63)
at Module._compile (module.js:571:32)
at Object.Module._extensions..js (module.js:580:10)
at Module.load (module.js:488:32)
at tryModuleLoad (module.js:447:12)
at Function.Module._load (module.js:439:3)
            </pre>
          </div>
        </div>
        <p>
          To be exact, Node will actually look for the find-me.js in more folders, but those are supported for mostly
          historic reasons and using them is no longer recommended. Also, core node modules are an exception here.
          The resolve step returns immediately for core modules.
        </p>

        <p>
          Let's see how Node actually resolve a non-core module. We'll use the first path in paths array, a node_modules directory
          under the current directory. We'll create on manually and simply add a find-me.js in there. Let's also add a console.log
          line in this file to identify it, and we'll do the same for index.js. When we now execute the index file, node will find
          a path to find-me.js and it will load it.
        </p>

        <div class="code-editor">
          <div class="code-title">index.js</div>
          <div class="code"></div>
          <pre>
console.log('In ./index.js');

require('find-me')
          </pre>
        </div>
        <div class="code-editor">
          <div class="code-title">find-me.js</div>
          <div class="code"></div>
          <pre>
console.log('In ./node_modules/find-me.js');
          </pre>
        </div>

        <div class="node-editor">
          <div class="node-code">
            <pre>
$ node index.js
            </pre>
          </div>
          <div class="node-output">
            <pre>
In ./index.js
In ./node_modules/find-me.js
            </pre>
          </div>
        </div>

        <p>
          If we want to only resolve the module and not execute it, we can use require.resolve method.
        </p>
        <div class="code-editor">
            <div class="code-title">index.js</div>
            <div class="code">
              <pre>
console.log('In ./index.js');

require.resolve('find-me');
              </pre>
            </div>
          </div>
          <div class="node-editor">
              <div class="node-code">
                <pre>
$ node index.js
                </pre>
              </div>
              <div class="node-output">
                <pre>
In ./index.js
                </pre>
              </div>
            </div>

            <p>
              This behaves exactly the same as require, but does not load the file. It will still
              throw an error if the file does not exist. This can be used, for example, to check
              whether an optional package is installed or not. If another find-me.js now existed
              of the any paths, for example, if we have a node module's directory under the home
              directory, and if we have a different find-me.js in there. Now if we execute the
              index file, the find-me.js file in this new route node_modules directory will not be
              loaded, because node already resolved find-me.js to the local file found under the
              local node_modules directory. But if remove the local file and execute again, Node
              will just pick the next closest find-me.js, and that would be the one under the home
              directory node_modules directory.
            </p>

            <p>
              Modules don't have to be files. We can also create a find-me folder under node_modules
              and place an index.js. Index is the default file name, but we can control what file name
              to start with under the folder using the main property in package.json
            </p>

            <div class="code-editor">
                <div class="code-title">
                  <pre>
package.json
                  </pre>
                </div>
                <div class="code">
                  <pre>
{{ '{' }}
  "name": "find-me",
  "main": "start.js"
{{ '}' }}
                  </pre>
                </div>
              </div>

              <p>
                Other than resolving modules from within the node_module folder, we can also place
                the module anywhere we want and require it with either relative paths, './', and
                '../', or with absolute paths, starting with '/'. If, for example, find-me was under
                the lib folder instead of a node_modules folder, we can still require it this way
              </p>
              <div class="code-editor">
                  <div class="code-title">
                    <pre>
index.js
                    </pre>
                  </div>
                  <div class="code">
                    <pre>
require('./lib/find-me');     
                    </pre>
                  </div>
                </div>
                
                <p>
                  What happens if the find-me module required the main index module and the index module
                  requires find-me module? This is where we get into what's known as the circular modular
                  dependency, which is actually allowed in Node. To understand it better, let's first
                  understand a few other concepts on the module object. First, let's talk about exports.
                  In any module, exports is a special object. We can put anything on the export object. It is
                  actually what we get in the findMeExports constant below. Let's console log this constant
                  and put an id attribute on the exports object in the find-me module to identify it. When we
                  test that, the findMeExports constant has that id attribute.
                </p>
                <div class="code-editor">
                    <div class="code-title">
                      <pre>
index.js
                      </pre>
                    </div>
                    <div class="code">
                      <pre>
const findMeExports = require('./lib/find-me');
console.log('findMeEports: ', findMeExports)
                      </pre>
                    </div>
                  </div>
                
                <div class="code-editor">
                    <div class="code-title">
                      <pre>
find-me.js
                      </pre>
                    </div>
                    <div class="code">
                      <pre>
exports.id = 'find-me';
                      </pre>
                    </div>
                  </div>

                  <div class="node-editor">
                      <div class="node-code">
                        <pre>
$ node index.js
                        </pre>
                      </div>
                      <div class="node-output">
                        <pre>
findMeExports: {{ '{' }} id: 'find-me' {{ '}' }}
                        </pre>
                      </div>
                    </div>

                    <p>
                      Let's also discuss about loaded attribute in Module object. Node keeps it false as long
                      as there is still more content to be loaded. So now we can get back to the original question,
                      what happens when module 1 requires module, and module 2 requires module 1?
                      Let's create an m1 module under the lib folder. We'll require it in index.js and console.log it.
                      Under the lib folder, m1.js, let's give it an id to identify it. Let's add some more content in
                      here. We'll start an array with one value and then push two more values after that. Let's duplicate
                      m1 as m2, and use different values in there. Now we'll make m1 require m2 somewhere before it's done
                      loading. Now to the interesting part, if anywhere within m2 we require m1 and printed it, we have a
                      circular reference. Node will partially print m1. At this point of the lifecycle of m2, the m1 module
                      is not ready yet, it still has 2 more lines be processed, but Node was able to share a partial
                      exports object from m1 to m2. In terms of the loaded attribute, in the last line of m2, the m1 
                      module had a loaded false attribute, while in the last line of index file, the m1 module has a loaded
                      true attribute.
                    </p>

                    <div class="code-editor">
                        <div class="code-title">
                          <pre>
index.js
                          </pre>
                        </div>
                        <div class="code">
                          <pre>
const m1 = require('./lib/m1');
console.log(m1) <span class="comment">// loaded: true</span>
                          </pre>
                        </div>
                      </div>
                    <div class="code-editor">
                        <div class="code-title">
                          <pre>
m1.js                  
                          </pre>
                        </div>
                        <div class="code">
                          <pre>
exports.id = 'm1';

exports.content = [1];
const m2 = require('./m2');
console.log(m2);
exports.content.push(11);
exports.content.push(111);
                          </pre>
                        </div>
                    </div>

                    <div class="code-editor">
                        <div class="code-title">
                          <pre>
m2.js
                          </pre>
                        </div>
                        <div class="code">
                          <pre>
exports.id = 'm2';

exports.content = [2];
exports.content.push(22);
exports.content.push(222);

const m1 = require('./m1');
console.log('m1 is not loaded yet', m1); <span class="comment">// loaded: false</span>
                          </pre>
                        </div>
                    </div>

                    <div class="node-editor">
                        <div class="node-code">
                          <pre>
$ node index.js
                          </pre>
                        </div>
                        <div class="node-output">
                          <pre>
m1 is not loaded yet {{ '{' }} id: 'm1', content: [ 1 ] {{ '}' }}
{{ '{' }} id: 'm2', content: [ 2, 22, 222 ] {{ '}' }}
{{ '{' }} id: 'm1', content: [ 1, 11, 111 ] {{ '}' }}
                          </pre>
                        </div>
                      </div>
                
      </div> <!-- end of .example -->
  </div>
</div>

<!-- 
    <h3>Wrapping and Caching Modules</h3>
  <p>
    Node's wrapping of modules is often misunderstood. To explain them, let me start by asking an
    important question. We can use the export object to export properties, but we cannot replace the
    export object directly. When we need to replace the export object, we need to use the module.exports
    syntax. The question is... why? Also, we've seen how the variables we define in the module scope here
    will not be available outside the module. Only the things that we export are available. So how come
    the variables are magically scoped and the exports object can't be replaced directly? The answer is
    simple. Before compiling a module, Node wraps the module code in a function, which we can inspect
    using the wrapper property of the module module. This function has 5 arguments: exports, require,
    module, __filename, and __dirname. This function wrapping process is what keeps the top-level
    variables in any module scoped to that module and it is what makes the module/exports/require
    variables appear to look global when, in fact, they are specific to each module. Same thing for the
    __filename/__dirname variables, which will contain the module's absolute filename and direcotry path.
    All of these variables are simply functions arguments whose values are provided to the wrapped
    function by Node. You can see this wrapping in action if you run a script with a problem on its firs line.
    This might actually depend on your environment, but on mine you can clearly see the anonymous
    wrapping function and its arguments here. Since we are in a function here, we can actually access the
    function's arguments in here, and you'll see how the first argument is the empty exports object, then
    we get the require object, then the module object, then filename and dirname. Not how both the
    require object and the module object are the copies associated with this index file. They are not global
    variables. The wrapping functions return value is this exports object reference. Note how we have both
    exports and the module object itself passed in the wrapper function. Exports is simply a variable
    reference to module.exports, so what happens here is equivalent to doing this line at the top of the
    module. So we can change the properties of the exports object, but if we change the whole export
    object, it would no longer be a reference to module.exports. This is the way JavaScript reference
    objects work everywhere, not just in this context. There is nothing special about require. It's a function
    that takes a module name or path and returns the exports object. We can simply override the require
    function to do our own logic if we want to. Say, for example, for testing purposes, we want every
    require line to be mocked by default and just returns an empty object instead of the required module
    exports object. This simple reassignment of require will do the trick, and if we test that by requiring
    any module and console logging that module, we'll get the mocked object by default. To explore this
    require object a bit more, let's say we have this simple trend function. It takes a numeric argument
    stars and a string argument header and it prints this header between the number of stars that we
    specify. And we want to use this file in two ways. We want to use it on the command line, just like this,
    by passing stars in the header arguments as command line arguments, but we also want to use it
    with require. We just require the file and then use whatever the file exports as a function and call that
    function. So those are two different usages here. And we need a way to determine if the file is being
    run as a script or if the file is being required. This is where we can use this simple if statement.
    If require.main = the module object. When, we run this as a script, this if statement will be true. So we
    can simply call the function here with process.argv elements. Otherwise, if require.main does not equal
    module, it means that this file is being required by other files. And in this case, we can just change the
    export's object to be the print function. And now we can test this script. It should work both from the
    command line directly, and when we run the index file, which requires the print stars.
  </p>

  <p>
      Caching is important to understand. Here is a simple example to demonstrate it. Say that we have this ascii-art
      file that prinst a cool looking header, and we want to display this header every time we require the file.
      So if we require this line twice, we want the header to show up twice. But because of module's
      caching, that's not going to happen. Node caches the first call and does not load the file on the second
      call. We can see the cache using require.cache, and in there you will find an entry for the ascii-art file.
      Those entries are indexed by the full file path. We can actually remove the cache entry here if we want
      to, using this full file path, and Node will re-load the module fine after that. But this is not the mstÂ§
      efficient solution for this problem. The simple solution for this case is to wrap the log line here in a
      function, and exports that insteads. Then when we require the file, we just execute the exports object as
      a function, and every time we do so, the function will execute the console.log statement.
  </p>


  <div class="code-editor">
      <div class="code-title">
        <pre>
  
        </pre>
      </div>
      <div class="code">
        <pre>
  
        </pre>
      </div>
    </div>
  
    <div class="node-editor">
      <div class="node-code">
        <pre>
  
        </pre>
      </div>
      <div class="node-output">
        <pre>
  
        </pre>
      </div>
    </div>

  <h3>Know You NPM</h3>
  <p>

  </p>

  <h2>Concurrency Model and Event Loop</h2>
  <h3>What is I/O Anyway</h3>
  <p>
    Okay, so we know that I/O is short for input/output, but what exactly does that mean? I/O is used to label a communication
    between a process in a computer CPU and anything external to that CPU, including memory, disk, network, and even another process.
    The process communicates with these external things with signals or messages. Those signals are input when they are received by the
    process, and output when they are sent out by the process. The term I/O is really overused, because naturally, almost every operation
    that happens inside and outside computer is an I/O operation, but when talking about Node's architechture, the term I/O is usually used
    to reference accessing disk and network resources, which is the most time-expensive part of all operations. Node's event loop is designed
    around the major fact that the largest waste in computer programming comes from waiting in such I/O operations to complete. We can
    handle requests for these slow operations in one of many ways. We can just execute things synchronously. This is the easiest way to
    go about it, but it's horrible because one request is going to hold up other requests. We can fork a new process from the OS to handle
    each request, but that's probably won't scale very well with a lot of requests. The most popular method for handling these requests is threads.
    We can start a new thread to handle each request. BBut threaded programming can get very complicated when threads start accessing shared resources.
    A lot of popular libraries and frameworks use threads. For example, Apache is multithreaded and it usually creates a thread per request.
    On the other hand, its major alternative, Nginx is single threaded, just like Node, which eliminates the overhead created by these multiple threads
    and simplify coding for sharde resources. Single threaded frameworks like Node use an event loop to handle requests for slow I/O opeartions
    without blocking the main execution runtime. This is the most important concept to understand about Node, so how exactly does this event loop work?
  </p>

  <h3>The Event Loop</h3>
  <p>
    The simplest one-line definition of the event loop is this - it's the entity that handles external events and converts them into
    callback invocations. Helpful? Maybe not. Let's try another definition: It's the loop that picks events from the event queue and pushes
    their callbacks to the call stack. This definition is probably worse than the first one. Truth is, it's not easy to understand the event loop
    without first understanding the data structures it has to deal with. It's also a lot easier to understand the event loop with
    visuals rather than text, so the next few clips will explain the various things around the event loop with visuals. What I want you to
    understand first is that there is this thing called the event loop that Node automatically starts when it executes a script, so
    there is no need for us to manually start it. This event loop is what makes the asynchronous callback programming style possible. Node will
    exit the event loop when there are no more callbacks to perform. The event loop is also present in browsers and it's very similar to the one
    that fires in Node. To understand event loop, wee need to understand all the players in this diagram and we need to understand how they interact.
    So V8 has this thing called stack, which we're going to cover in details in the next section. It also has a heap. The heap is simple, it is
    where objects are stored in memory. It's basically the memory that gets allocated by the VM for various tasks. For example, when we invoke a function,
    an area in this heap is allocated to act as the local scope of that function. Both the Stack and the Heap are part of the run-time engine, not
    Node itself. Node adds APIs like timers, emitters, and wrappers around OS operations. It also provides the event Queue and the event loop using the
    libuv library. The event loop,  as the name cleary describes, is a simple loop that works between the event queue and the call stack.
    But again, we can't understand it without first understanding those other entities.
  </p>

  <h3>The Call Stack</h3>
  <p>
    The V8 Call stack which is simply a list of functions. A stack is a first in last out simple data structure. The top element
    that we can pop out of the stack is the last element that we pushed into it. In the case of V8 Call stack, these elements are
    functions. Since JavaScript is single threaded, there is only one stack, and it can do one thing at a time. If the stack is executing
    something, nothing else will happen in that single thread. When we call multiple functions that call each other, we naturally
    from stack. Then we back-track the function invocations all the way back to the first caller. Remember how if you want to implement
    something that's recursive without recursion you need to use a stack? Well, that's because a normal recursive function will use
    a stack anyway. Let's walk through a simple example to demonstrate what happens in the stack when we call functions. Here we have three
    simple functions, add, double (which calls add), and printDouble which calls double, and let's assume that all these functions are
    wrapped in an immediately invoked function expression. When we run this code, V8 uses the stack to record where in the program it is currently
    executing. Every time we step into a function, it gets pushed to the stack, and every time we return from a function, it gets popped out
    of the stack. It's really that simple. So we start with the IFFE call, which is an anonymous function. Push that to the
    stack. The IFFE function defines other functions, but only executes printDouble. That gets pushed to the stack.
    PrintDouble calls double, so we push double to the stack, double calls add, we push add to the stack and so far,
    we're still executing all functions. We have not returned from any of them. When we return from add, we pop add out of the stack.
    We're done with it. Then we return from double, so double gets poped out of the stack, too. Now, the execution continues in printDouble.
    We get into a new function call, console.log, that get's pushed into the stack and popped immediately, because it did not call any other function.
    Then we implicitly return from printDouble, so we pop printDouble out of the stack and finally pop the anonymous IIFE itself out of the stack.
    Note how every time a function is added to the stack, it's arguments and local variables are added too in that same lavel. You'll
    sometimes hear the term stack frame to reference the function and its arguments and local variables. I
    am pretty sure you have seen the call stack before, if not in node then the browser. Every time yo get
    an error, the console will show the call stack. For example, I changed add to use an undefined vaiable
    here, which will raise an error. When we execute this code in Node or the browser, we'll get an error
    report which includes the call stack, the anonyous function calls printDouble, which calls double,
    which calls add. This is the state of the call stack when the error happened. And what do you think will
    heppn if a function calls itself recursively without an exit condition? It's the equivalent of an infinite
    loop, but on the stakc. We'll keep pushing the same function to the stack until we reach the V8 size limit for the 
    stack, and V8 will error out with this error: Maximum call stack size exceeded.
  </p>

  <h3>Handling Slow Operations</h3>
  <p>
    As long as the operations we execute in the call stack are fast, there is no problem with having a single
    thread, but when we start dealing will slow operations, the fact that we have a single thread becomes a
    problem, because these slow operations will block the execution. You do know that we can still write blocking
    code in Node, right? For example, a long for looping is a blocking operation. In here the slowAdd function will
    take a few seconds to complete, depending on the hardware, of course. So what happens in the call stack when we step
    into a blocking function like slowAdd? Well, the first time we step into it, it gets pushed to the stack, and then we wait
    until V8 finishes that useless blocking loop and returns from slowAdd(3,3) which gets popped out of the stack at that point.
    Then we step into slowAdd 4 4, and we wait, done, return, pop. Same thing for slowAdd 5 5, wait, done, return, pop.
    Then we get into the console.log lines, which are fast and thus non blocking, so push, pop, push, pop, push, and pop.
    Let me actually show you how Node behaves when we executes this exact code, slowAdd, wait, slowAdd, wait, print, print, print.
    While Node is waiting after every slowAdd here, it cannot do anything else. This is blocking programming, and
    Node's event loop exists to allow us to avoid doing this style of programming.
  </p>

  <h3>How Callbacks Actually Work</h3>
  <p>
    We all know that Node API is designed around callbacks. We pass functions to other functions as
    arguments, and those argument functions get executed at a later time, somehow. For example, if we
    change our slowAdd function to output the result in a setTimeout call after five seconds, the first
    argument to setTimeout is the function that is famously known as a callback. So let's see what
    happens on the stack for this case. We call slowAdd 3 and 3, push that to the stack, slowAdd calls
    setTimeout, so we push that to the stack, since setTimeout does not call any functions but rather has a
    function argument, it gets popped out of stack immediately, and at that point, slowAdd 3 and 3 is
    done, so we pop that out of the stack too. Then we continue, slowAdd 4 and 4, push it to stack, calls
    setTimeout, push that to the stack and immediately pop it, then pop slowAdd 3 and 3, then somehow,
    console.log(6) gets added to the stack to be executed, and after that, console.log(8) gets added to the
    stack to be executed. To understand how the last two calls to console.log appeared in the call stack,
    let's take a look at the bigger picture here. First, it's important to understand that an API call like
    setTimeout is not part of V8. It's provided by Node itself, just like it's provided by browsers, too. It's
    wired in a way to work with the event loop asynchronously. That's why it behaves a bit weirdly on the
    normal call stack. Let's talk about the event queue, which is sometimes called the message queue or
    the callback queue. It's simply a list of things to be processed. Let's call these things events. When we
    store an event on the queue, we sometimes store a plain-old function with it. This function is what we
    know as a callback. A queue data structure is a first in first out structure, so the first event we queue
    will be the first event to get de-queued. To de-queue and process an event from the edge of the
    queue, we just invoke the function associated with it. Invoking a function will push it to the stack. So
    we start with the anonymous function, it puhsed slowAdd 3, 3 to the call stack, which in turn pushes
    setTimeout cb 1, delay of 5 seconds. The setTimeout callbacks here in this example are actually
    anonymous functions, but to simplify the visualization, I labeled them cb1 and cb2. At this point, Node
    sees a call to its setTimeout API, takes note of it, and instantiate a timer outside of the JavaScript
    runtime. The setTimeout call on the stack will be done and popped out, and while the Node timer is
    running, the stack is free to continue processing its items. It pops slowAdd 3, 3, pushed slowAdd 4, 4,
    which in turn pushes setTimeout with the second callback. Node kick off another timer for this new
    setTimeout call and the stack continues to pop its done functions. After five seconds, both timers
    complete, and when they do they queue the callbacks associated with them into the event queue.
    Exactly at this moment, the event loop has something important to do. The event loop job is super
    simple. It monitors the call stack and the event queue. When the stack is empty, and the queue is not
    empty (there are events waiting to be processed in the queue), it will de-queue one event from the
    queue and push its callback to the stack. It's called an event loop, because it loops this simple logic
    until the event Queue is empty. Right now, our example's call stack is empty and the queue is not. The
    event loop will pick cb1, and push it to the stack. Cb1 will push console.log call to the stack, which
    returns immediately, and this marks cb as done. The stack is empty again, and we still have one event
    to proess, so the event loop will push cb2 to the stack and cb2 pushes console.log, done, pop, cb2 is
    done, and we are at an idle state now for the event loop. The stack is empty and the queue is empty.
    Node will exit the process when we reach this state. All Node APIs work with this concept. Some
    process will go handle a certain I/O asynchronously, keeping track of a callback, and when it's done it
    will queue the callback into the event queue. Keep in mind that any slow code being executed on the
    stack directly will block the event loop. Similarly, if we're not careful about the amount of events that
    get queued in the event queue, we can overwhelm the queue and keep both the event loop and the
    call stack busy. As a Node developer, these are some of the most important things to understand
    about blocking vs non-blocking code.
  </p>
  
  <h3>setImmediate and process.nextTick</h3>
  <p>
    What happens when the timer delay is 0 milliseconds? Well, almost the same thing. The main function
    pushes slowAdd 3 3, which pushes the setTimeout, which creates the timer. The timer immediately queues
    its callback on the queue. However, the event loop will not process that event, because the stack is
    not empty. So the stack continues its normal flow until we get to the second timer, which also immediately
    queues its callback. The stack is still not empty. After we pop all calls from the stack, the event loop
    picks the first callback and pushes that to the stack, and then does the same thing with the second one.
    Because of this loop, the timers are not really executed after 0 milliseconds, but rather after we're
    done with the stack, so if there was a slow operation on the stack, those timers will have to wait. The
    delay we define in a timer is not a guaranteed time to execution, but rather a minimum time to execution.
    The timer will execute after a minimum of this delay. Node's event loop has multiple phases. The timers
    run in one of those phases while most I/O operations run in another phase. Node has a special timer,
    setImmediate, which runs in a separate phase of the event loop. It's mostly equivalent to a 0ms timer,
    except in some situations, setImmediate will actually take precedence over preiously defined 0ms setTimeouts.
    For example, this code will always display immediate before timeout, although we kick the 0ms timeout first.
    It's generally recommended to always use setImmediate when you want something to get executed on the next
    tick of the event loop. Ironically, Node has a process.nextTick api that is very similar to setImmediate,
    but Node actually does not execute its callback on the next tick of the event loop, so the name here is
    misleading, but it's unlikely to change. Process.nextTick is not technically part of the event loop, and 
    it does not care about phases of the event loop. Node processes the callback registered with nextTick after the
    current operation completes and before the event loop continues. This is both useful and dangerous,
    so be careful about it, especially when using process.nextTick recursively. One good example for using
    nextTick is to make for a standard function contract. For example, in this script, the fileSize function
    receives a fileName argument and a callback. It first makes sure the fileName argument is a string, and
    it executes the callback with an error if not. Then, it executes the async function fs.stat and executes
    the callback with the file size. An example use of the fileSize function is here where we log the file size.
    Very simple. If we execute it with the current file name, it should log the size of this file. This call was
    async because we saw the Hello message first, which is expected beause of our use of the async
    fs.stat function. But something is wrong with this fileSize function. Can you identify it? Let me give you
    a hint. Let's trigger the validation by passing anumber instead of a string here. Validation is a go, but
    the console Hello line was not executed at atll in this case, because the validation code here is
    synchronous. So the fileSize function could be both sync and async depending on the first argument.
    This is usually a bad design. A function should always be either sync or async. To fix this problem,
    instead of directly calling the callback with an error here, we can use process.nextTick call for the
    callback, and with the argument of the error that we want. This way, when we actually trigger, the
    validation, the error will happen asynchronously and the file size function is going to be always async.
  </p>

  <h2>Node for Networing</h2>
  <h3>TCP Networking with the Net Module</h3>
  <p>
    Let's create a basic network server. We use the net's module, create server method.
    We then need to register a connection handler that fires every time ad client connects
    to this server. When that happens, let's log to the console and see if the client is connected.
    The handler also gives us access to a connected socket itself. This socket object implements
    a duplex stream interface, which means that we can read and write to it. Let's write "Welcome
    new Client". To run the server we need to listen to a port, and the callback here is just to
    confirm it. Let's test. Testing this is simple, we can use either telnet or netcat.
    For example, nc localhost 8000, we get the client is connected message in the server console, and
    the welcome message is sent to the client, and then node keeps running, because we did not terminate
    that connection. Now the client can write to that socket, but we have not registered a handler to read
    from the socket. The socket being a duplex stream means that it's also an EventEmitter. So we can listen
    to data event on the socket. The handler for this event gives us access to a buffer object. Let's console
    log it. Now when the client types something, we get it as a buffer. This is great, because Node does not
    assume anything about encoding. The user can be typing here in any language. Let's now echo this data
    object back to the user using socket.write. When we do so, you'll notice that the data we are writing back
    is actually a string. This is because the write method on the socket assumes a utf8 encoding here.
    This second argument can be used to control the encoding and the default is utf8. We can also globally
    set the encoding if we need to, so the global encoding is now utf8 and the data argument here becomes
    a string instead of a buffer, because we now told Node to assume a utf8 encoding for anything received
    from this socket. Both the console log line and the echoed data are assumed to be utf8. I'm gonna keep
    an example without global encoding, just in case we need access to the buffer object. What happens
    when the client disconnects? The socket emitter has an on 'end' event that gets triggered when the
    client disconnects? The socket emitter has an on 'end' event that gets triggered when the client disconnects.
    At that point, we can't write to the socket any more. Let's console log that client is disconnected.
    Let's test that now. Connect, and we can disconnect a netcat session with Cmd+D. The server logs the line.
  </p>

  <h3>Working with Multiple Sockets</h3>


  <h2>Node for Web</h2>
  <h3>The Basic Streaming HTTP Server</h3>
  <p>
    HTTP is a first class citizen in Node. In fact, node started as web server and evolved into
    much more generalized framework it is today. Node's HTTP module designed with streaming and low latency
    in mind. Node is today a very popular tool to create and run web servers. Let's look at the typical hello-world
    example for Node's http module. We create a server using the HTTP module create server method, which gives
    us, no surprise there, an event emitter object. That event emitter has many events, one of which is the request
    event, and this even happens every time a client connects to this http server. It exposes a request object and a
    response object. We can use the response object to modify the response Node will be using for that request.
    In here, we respond with 200 ok, content-type text, and the text 'hello world'. The server runs on port 8000.
    When we run this script, node will not exit, because it has a listener handler and it will respond to any
    http request on port 8000. If we inspect the headers this simple http server is sending, we'll see http 1.1,
    this is the current most recent version of http that's supported in browsers. Response code is 200 ok, and the content-type
    is what we set it to, and we have a connection keep-alive and transfer-encoding is chunked. Keep-alive means
    that the connection to the web server will be persisted. The tcp connection will not be killed after a request
    receives a response, so that they can send multiple requests on the same connection. Transfer-encoding chunked is used
    to send a variable length response text. It basically means that the response is being streamd! Node is ok with us
    sending partial chunked reponses, because the response object is a writable stream. There is no response length value
    being sent. After Node sends the 200 ok here, it can do many other things before terminating the response, and instead
    of inefficiently buffering everything it wants to write in memory and then write it at once, it can just stream
    parts of the response as they're ready. So this very simple http server can be used, for example, to stream video files
    out of the box. But remember that the connection is not terminated here, so the browser knows that the content
    is done through the http protocol. Http 1.1 has a way of terminating a message, and it's what happens when we use the
    response .end function. Si if we don't actually use the end method, if we use the write method instead, in this case,
    when a client connects, they get the 'hello world', but the response is not terminated, because basically Node is still streaming.
    In fact, in here, we can define a timer function. Let's make that fire after on second. And inside this function,
    we'll go  ahead and write another message. And how about we write yet another message after two seconds? Let's try it.
    Run the server. Connect. And you'll see 'hello world'. After one second you'll see another message, and after two seconds
    you'll see the third message. And the server is still streaming. We have not instructed http to terminate the response object.
    Let's make the timeout periods here a little bit longer. Lets do 10 seconds and 20 seconds and test that. Initiate an http request.
    I see the 'hello worl'. Node is not really sleeping, it's just idling, and it can actually handle other client
    requests during this idling phase, thatnks to the event loop. Both of these requests are being handled concurrently with the
    same node process. Please note, however, that terminating the response object with a call to the end method is not optional, you have to do it for
    every request. If you don't, the request will timeout after the default timeout period, which is set to two minutes.
    As you can see, this right line did not happen, beause it's delayed till after the default server timeout.
    We can actually control the server timeout using the timeout property, so this line will make the timeout one second,
    and you'll see now how the server is going to timeout right away.
  </p>

  <h3>Working with HTTPS</h3>
  <p>
    HTTPS is the HTTP protocol over TLS/SSL. Node has a separate module to work with HTTPS, but it's very similar to the
    HTTP module. To convert the basic HTTP server example to work with HTTPS, all we need to do is require https instead
    and provide the createServer method with an options object. This object can be used to configure multiple things. Usually
    we can pass key and certificate. Those can be buffers or strings to represent a private key and the certificate. We can also pass
    a pfx option to combine them if you want. I'll just use key insert and let's walk through a complete example. We first need to generate
    a certificate. We can use the openssl toolkit for that, which will allow us to first generate a certificate. We can have it
    encrypted or not encrypted. And it will allow us to generate a certificate signing request (CSR), and then self-sign this certificate to test it.
    Of course, the browsers will not trust our self-signed certificate, but it's good for testing purposes. We can actually combine all these
    steps wit one command that will output a private key and a certificate file for us. It will ask for some information, but since
    it's all just a test, you can use the default answers here. When this command is done, you should see a key,pem file, and a cert.pem file in the
    working directory. Now that we have these files, we just need to pass them here to the create server method. We can use the fs module to do that.
    We'll do readFileSync. Since these files are to be read once, and used for creating a server, this is okay here. We'll do ./, the key.pem file, and same
    thing for the cert. So it's cert.pem and of course we need to require the fs module, and the last thing we need to do is to change this port
    to 443, which is the defaultport for https communication. To test all that, we need to execute the script. In my environment I need to sudo this command
    to get access to the 443 port. So sudo node https.js an we have an https server. So we can go to https locaholst and the browser is going to warn us
    about the self-signed certificate. It simply means that hte bworser does not recognize this certificate, but we can trust it manually.
    And there you go, very simple.
  </p>

  <h3>Requesting HTTP/HTTPS Data</h3>
  <p>
    Node can also be used as a client for requesting http and https data. There are five major classes of objects in Node's HTTP module. The Server class
    is what we use to create the basic server, it inherits from net.Server, so it's an EventEmitter. A ServerResponse object gets created internally by an
    HTTP server. The http.Agent class is used to manage pooling sockets used in HTTP client requests. Node uses a global agent by default, but we can
    create a different agent with different options when we need to. When we initiate an HTTP request, we will be working with a ClientRequest object. This is
    different from the request object we've seen in the server example. That request object is actually an IncomingMessage object, which we're gonna see in a little bit.
    Both clientRequest and serverResponse implement the writable stream interface. IncomingMesssage objects implement the readable stream interface, and all
    three objects are event emitters. We've seen the basic server example. Let's see a basic requesst example. Let's request the HTML page at google.com with Node.
    We can use the http.request method. This method takes an option argument and it gives us access to a callback with a response for the host that we're gonna request.
    We can specify many options here. To request google.com, we need hostname is google.com, and we can use multiple other options here. For example, the default
    method is GET, but we can use a method like POST if we need to post information to a hostname. I'll leave it default, and in here we can console log the response,
    which is going to be the html at google.com. You'll notice one thing about the handler that we define in the second argument here, it doesn't have an error
    argument. It's simply because that this handler gets registered as an event listener and we also handle the error with an event listener here. So this http
    request method returns an object, and that object is an event emitter. So we can register a handler for the error event. And we can do something like
    request.on error, and handle the error in that case. Since this request object is a writable stream, we can do things like write, for example, if we're
    writing with a post method. But for get requests, we don't need that. We just need to terminate the stream ,so we do .end here and that should do it. Let's test.
    So node request and I'll pipe it on less and you'll see the response object here is an incoming message. So we can read information on this response object like status
    code.We can also read response.headers, for example, and this response object is an event emitter. It emits a data event when it receives data from the hostname. This
    data event gives us callback, and that callback's argument is a buffer. So if we want to see the actual HTML, we do toString on it, so let's actually take a look at that.
    You'll see the status code 200, the headers object, and you'll see the actual html for google.com. If we're not writing any information to the headers
    request or if we're not posting or putting or deleting data, we could actually just use the get method here. This get method is simpler. Its first argument is
    just a string with the URL that we want to read, so we need to add the http protocol in here, and we don't need to do a request.end on this. That will be done for us. So this should
    be equivalent, and this request is done using the global http agent. So the http module has a globalAgent, which node uses to manage the sockets here.
    It has some pre-configured options. We can see that agent information here if we do a request.agent. So in here you'll first see the agent information and
    then you'll see the printed information from the response. And all this interface is exactly the same if we want to work with https instead of http.
    So if we want to fetch https google.com, all we need to is replace http with https, and things will work exactly the same, but it's now
    communicating the request over https. So let me now show you where to identify these objects in the examples we.ve seen so far. In this example, the request object
    here is from the class clientRequest. This response object is of type incomingMessage. And the agent that was used for the request is of type http Agent.
    In the server example, the server object is from the http server class, the request object inside the request listener is from the incomingMessage class,
    and the response object is from the server response class.
  </p>

  <h3>Working with Routes</h3>
  <p>
    Let's see how we can work with routes using Node's http module. We have a basic server here, and what I want to do I want to support some routes. Let's try
    to support a home route, an api route, and see how we can respons to different things in there. So, to support that, we need to first read the URL
    information, and this is easy. We can use req.url to do so. So now, when I request localhost, the req/url is slash, and anything I put here I will be able to read it.
    So, to handle routes, all we need to do is we need a switch statement for this req.url. So what should we do when it's slash? Ir, what should we do when it's
    home, and so on? Let's assume that we have a /home.html file, very basic template HTML, and we want to display this file when we go to slash home. All we need to do is
    write the header, which in this case is text HTML, and then in here we want to read home that HTML and write it to the response. So we can use fs.readfileSync ./home.html.
    And of course, we need fs module and let's try it. Excellent. What if we have an about.html and now we also want to support /about.
    It's exact same code as this portion. So we can actually make it dynamic. Let's make it support both home and about, and let's make it support dynamic,
    because this is the exact req.url part. So first convert this into a template string and then this part becomes variable req.url, just like that. Let's test.
    We can now see the about page and the home page. So what should we do on the root route? How about we redirect the uer to /home? With Node, we just write a header for that.
    So it's writeHead, and we'll just use 301 here to indicate a permanent move, and the ehader that we want to write here is the location header.
    So, this is permanently moved to /home. And we still need to end the response, so now when we request the slash route, it will tell us that it was moved
    permanently to slash home. By the way, this first number here is the http status code. We can actually take a look at all the status codes using http.status_codes.
    You'll see all of them here. 301 is movde permanently. If you need to work with json data, say that we have a route there. We'll make it /api, so this route
    is going to respond with some data. Let's assume that we have the data here is a constant. This data is some kind of object and we want to respond with this data json,
    o we need to do two things. First, the content type in this case is application/json. And the information that we want to write here is a stringified version
    of the JSON object. So it's json.stringify the data variable. And we can test that. So in here if we go to /api, we'll get back a json response.
    Now what happens if we request something that does not exist? Rigth now, the server does not respons with anything adnd it will eventually timeout. So this would be this
    default case here, so we should probably respond with 404, in this case. So 404 means not found. We should still end the response here, so let's try it now.
    It will give me a 404 not found.
  </p>

  <h3>
    Parsing URLs and Query Strings</h3>
  <p>
    If you need to work with URLs, especially if you need to parse URL, Node has this URL module that you can use. It has many methods, but the most
    important is parse. The format method is also useful. So let me show you how to work with that. Before we do, let's take a look at the url api
    documentation from the nodeJS.org website. This diagram here has details on all the elements of a URL. This example is manually parsing this URL in here.
    So you can see we have the protocol, which is HTTP. There is the authentication part, which is username and password in case we have those, and then
    there is hostname and port, and both of them together is a host. And there's the path name, which is what comes after the host and before the query string.
    And then with a query string, the question mark including the query itself we call it search, but without the question mark we call it query. And pathname + search
    is called path. And if we have a hash location here it will be called hash. These are all the elements in any URL object. So if we have the URL as a
    string and we need to parse it into those elements, we can use the URL parse method. For example, I can use the url.parse method to parse this URL that I just
    grabbed from Pluralsight search, and this call is going to give me all the elements that I have in that URL. We have an HTTPS protocol. We don't have any
    authentication data. The host is pluralsight.com, and since the port is null the host and hostname is the same, there's no hash, there's a search part query part hash
    name path and the of itself, which is the full URL. We can actually also specify a second argument here true to parse the query string itself, so if we do that
    the query string will be parsed ,and reading information from the query string is as easy as doing .query.queue, for example. This will give me exactly the search
    query for that URL. If, on the other hand, you have the inverse situation, if you have an object with all these elements detailed and you want to format this
    object into a URL, you can use the url.format method. And this will give you back a string with all these URL object properties concatenated in the right way.
    If you only care about the query string, the you can use the query string module, which has many methods, as you see, but the most importantones are the parse
    method and this stringify method. So if we have an object like this one and we want to convert this object into a query string portion, all we need to do is call
    queryString.stringy on that object, and it will give me an actual string I can use in any url query. And you can see how this stringify method escaped some special
    characters by default, which is great. If you have the inverse situation, if you have a query string and you want to parse it into an object, what you need here is queryString.parse,
    and you give the string that you want to parse, and this will give you back an object parsed from that query string.
  </p>
 -->